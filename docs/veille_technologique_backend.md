# Veille technologique — Backend API Kanban (NestJS, Symfony, Spring Boot)

## NestJS (Node.js/TypeScript)
NestJS est un framework Node.js orienté vers l’architecture modulaire et l’injection de dépendances, fortement inspiré d’Angular. Il s’appuie sur TypeScript, Express (ou Fastify) et une structure d’application opinionated qui favorise la maintenabilité. Les avantages: productivité rapide grâce aux CLI et générateurs, intégration fluide avec TypeORM/Prisma, écosystème riche (GraphQL, Swagger, validation, cache, CQRS), DX très forte et courbe d’apprentissage douce pour les développeurs JS/TS. La modularité (Modules/Providers/Controllers) rend les responsabilités explicites et facilite les tests. Les inconvénients: surcoût d’abstraction (décorateurs, réflexion) et overhead runtime par rapport à des stacks plus proches du métal; moins mature que Java/Spring sur certains patterns d’entreprise; dépendance à l’écosystème Node (boucle d’événements, single-thread par worker) pouvant exiger une stratégie de scaling et d’observabilité adaptée. En résumé, NestJS convient parfaitement aux APIs modernes orientées développeurs, itératives et rapides, tout en permettant une architecture propre et testable.

## Symfony (PHP)
Symfony est un framework PHP mature, modulaire et très stable, reconnu pour sa robustesse et sa communauté. Il fournit un ensemble de composants réutilisables (HTTP Foundation, Routing, Console, DependencyInjection) et un full-stack avec Twig, Security, Messenger, etc. Avantages: stabilité long terme, riche écosystème (Doctrine ORM, API Platform), outillage de qualité (MakerBundle, Flex), documentation exhaustive, excellentes pratiques (config, tests, environnement). Pour une API, API Platform accélère fortement la mise en place avec pagination, filtres, validation et documentation. Inconvénients: verbosité plus élevée qu’en Node; performances correctes mais généralement inférieures aux stacks JVM; culture et outillage différents de JS/TS pouvant ralentir une équipe orientée front JS; temps de démarrage inférieur à Node mais déploiements PHP-FPM/Nginx nécessitent une expertise DevOps. Symfony brille pour les projets orientés stabilité, conformité et où la communauté PHP est forte.

## Spring Boot (Java)
Spring Boot industrialise le développement d’applications Java en réduisant la configuration via autoconfiguration et starters. Avantages: performances JVM, robustesse, outillage d’entreprise (Spring Data, Security, Actuator), écosystème mature (Cloud, Batch), scalabilité et observabilité avancées. Le typage fort et la qualité des librairies favorisent la fiabilité et les tests. Inconvénients: empreinte mémoire plus élevée; temps de build/démarrage plus longs (atténuables avec GraalVM/Native Image); courbe d’apprentissage plus raide pour une équipe non Java; verbosité et configuration parfois complexes. Spring Boot est un excellent choix pour des SI critiques, des besoins de conformité, de performance constante et d’intégration avec l’écosystème Java.

## Justification du choix — NestJS pour notre Kanban API
Nous privilégions NestJS pour plusieurs raisons. D’abord, l’alignement fort avec notre stack front et les compétences de l’équipe en TypeScript maximise la vélocité et la maintenabilité partagée. Ensuite, l’écosystème intégré (GraphQL, Swagger, validation, Auth/JWT, TypeORM) accélère la livraison des fonctionnalités requises par un Kanban (authentification, gestion d’utilisateurs, listes, cartes) avec une architecture claire et testable. La modularité de NestJS convient à une montée en complexité progressive (guard/roles, CQRS, websockets pour temps réel) tout en restant compréhensible. Par rapport à Symfony, NestJS évite la fracture linguistique JS/PHP et s’intègre mieux aux outils Node de l’équipe. Par rapport à Spring Boot, il réduit l’empreinte et la courbe d’entrée, tout en offrant des performances suffisantes pour notre charge prévue; nous pourrons scal­er horizontalement et employer Fastify si nécessaire. Enfin, la documentation, les CLIs et la communauté Nest renforcent la productivité et la qualité, tout en nous permettant d’explorer des optimisations (cache, dataloader, profiling) à moyen terme.